# 019 委托详解

---

[toc]



> :hourglass: 2023-7-27 12:25:01 



> 摘要
>
> 1. 什么是委托 ?  委托的发展简史
> 2. 委托的声明    -->  如何 自定义委托 
> 3. 委托的使用  ---> 一般用法,高级用法, **避免不恰当的委托使用方法**





----



## 什么是委托?

> 委托 delegate  是 函数指针的 "升级版"
>
> * 实例:    C/C++ 中的 函数指针



> 一切 皆 ==地址== 
>
> *  变量(数据)  是 以 某个地址为 起点的一段内存中 所存储的值
> *  函数(算法)  是 以 某个地址为 起点的 一段内存中所存储的 一组机器语言指令 ;

>  直接调用  与 间接调用 
>
> *  直接调用:   通过 函数名来调用 函数,  CPU 通过函数名 直接获得 函数所在地址并开始执行 -->返回
> * 间接调用:    通过函数指针来调用函数,  CPU 通过读取 函数指针存储的值==获得函数所在地址==并开始执行 ,返回



>  Java中没有与  委托相对应的 功能实体 



> 委托的简单使用 
>
> * Action委托
> * Func委托





----

## 委托的声明(自定义委托)

* 委托是一种类 (Class) ,  类是 数据类型,所以 委托 也是一种数据类型 

  * 委托 可以声明变量,创建实例

* 委托的 声明方式 , 与 一般的类 不同,   主要 为了 照顾  可读性 和  C/C++传统

* 注意声明 委托的位置 

  * 避免写错地方 结果声明成 嵌套类型

  * > 委托 一般声明到  名称空间体内,而不是  类文件内;  

* 委托 与   所封装的 方法 必须  "类型兼容"

  * 返回值的数据类型一致

  * 参数列表 在 个数  和  数据类型上 一致 ( 参数名 不需要一致)

  * > 方法 能否 被 委托, 是通过 参数类型和返回值类型 以及参数个数,参数顺序来判定的 ,



>  自定义 委托的 声明  和  使用 



> C#编程语言中 有2个内置委托 , 一个是 Action ,一个是 Func ; 
>
> * 前者 调用无返回值的委托
>   * 后者 调用 有返回值的委托 ;	



```c#
// 查看 "委托"  是否是  一种 "类"

class Program 
{
    static void Main(strinig[] args)
    {
        Type t = typeof(Action);
        Console.WriteLine(t.IsClass);  // 输出 True ,说明委托是一个类
    }
}
```



---

### 声明注意点 

1. 优先将 	`委托`   声明到 ==类型==层面,, 而非 ==类型成员== 层面 
2. 委托的调用都是 间接调用, 2种调用风格, 一个是C#官方调用, 一个是 C/C++函数指针风格调用

---

> :warning:  现场 这边不适合 复现代码, 适合理论学习
