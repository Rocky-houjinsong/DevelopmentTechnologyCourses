# 设计模式原则

---

要尽可能地保证==程序的可扩展性、可维护性和可读性== 



## 单一职责原则

---

封装指的就是将单一事物抽象出来组合成一个类，所以我们在==设计类==的时候每个类中处理的是单一事物而不是某些事物的集合。

> 单一职责原则，就是对一个类而言，应该仅有一个引起它变化的原因，其实就是将这个类所承担的职责单一化

软件设计真正要做的事情就是，根据需求发现职责，并把这些职责进行分离，添加新的类，给**当前类减负**，越是这样项目才越容易维护。

## 开放封闭原则



---

> 开放 – 封闭原则说的是软件实体（类、模块、函数等）可以扩展，但是不可以修改。
> **对于扩展是开放的，对于修改是封闭的。**

> :star:需要在这些位置创建抽象类来隔离以后发生的这些同类变化（其实就是对多态的应用，创建新的子类并重写父类虚函数，用以更新处理动作）
> 抽象类只需要包含虚函数（纯虚函或非纯虚函数）能够实现多态即可。

开放 – 封闭原则是面向对象设计的核心所在，这样可以给我们设计出的程序带来巨大的好处，使其可维护性、可扩展性、可复用性、灵活性更好





## 依赖倒转原则

---

关于依赖倒转原则，对应的是两条非常抽象的描述：

1. 高层模块不应该依赖低层模块，两个都应该==依赖抽象==。
2. 抽象不应该依赖细节，细节应该依赖抽象。

高层模块：可以理解为上层应用，就是业务层的实现
低层模块：可以理解为底层接口，比如封装好的API、动态库等
抽象：指的就是抽象类或者接口，在C++中没有接口，只有抽象类



#### 里氏代换原则

---

>  子类类型必须能够替换掉它们的父类类型。
> 高层模块不应该依赖低层模块，两个都应该==依赖抽象==。

> 关于这个原理的应用其实也很常见，比如在Qt中，所有窗口类型的类的构造函数都有一个QWidget*类型的参数（QWidget 类是所有窗口的基类），通过这个参数指定当前窗口的父对象。虽然参数是窗口类的基类类型，但是我们在给其指定实参的大多数时候，指定的都是子类的对象，其实也就是相当于使用子类类型替换掉了它们的父类类型。
>
> 这个原则的要满足的第一个条件就是继承，其次还要求子类继承的所有父类的属性和方法对于子类来说都是合理的
>



#### 依赖倒转原则

> 抽象不应该依赖细节，细节应该依赖抽象

抽象类中提供的接口是固定不变的

低层模块是抽象类的子类，继承了抽象类的接口，并且可以重写这些接口的行为

高层模块想要实现某些功能，调用的是抽象类中的函数接口，并且是通过抽象类的父类指针引用其子类的实例对象（用子类类型替换父类类型），这样就实现了多态


![依赖倒置](https://subingwen.cn/design-patterns/three-principles/image-20220829010553911.png)