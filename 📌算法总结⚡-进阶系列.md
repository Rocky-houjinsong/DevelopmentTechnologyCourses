

----









## 



<font size= 4, color = red>数缺形时少直观，形少数时难入微，数形结合百般好，隔离分家万事休</font>

----

# 数据结构

----



## 线性表

---







## 00查找篇

---

### 二分查找- ✅

---

> **使用条件**  :  
>
> 1. 数组 有序 
> 2. 数组 无重复元素



> **难点**:
>
> 1. 边界条件的确定   <font  size = 5, color = red> 开闭区间</font>
> 2. 循环中 <font size = 4, color = red> 循环不变量 </font>

> **思路**:
> nums[middle] 与 target 比较 ,借助比较结果 来 调整(缩小)比较范围

> **步骤**: 
>
> 1. 初次边界值设定     <font size = 4, color = red>  赋可取值, 基于边界来判定</font>
> 2. 循环终止条件 设定      <font size = 4, color = red> 区间是否存在待比较元素</font>
>    * 中间值设定
>    * 中间值 与 目标值  三种 判定结果   --- 中间值 偏哪, 哪边 变动
>      * 中间值大  --- 在左区间, 重设右边界值
>      * 目标值大 --  在 右区间  重设左边界值 
>      * 目标值等于 中间值  ---  结束 



> 左闭右闭 :  left = right ,此时区间 存在一个元素, 是有效的 ,
> 左闭右开: left = right 此时区间不存在元素, 是无效的



```c++
int middle = left + ((right - left) >> 1);
// right - left表示right与left之间的距离，然后>> 1将这个距离右移1位，相当于将距离除以2。最后再加上left，就得到left和right的中间值
```





## 01排序篇

---

### 选择排序✅

---

>  `已排序`  , `未排序`
>
>  未排序中获取 最小值, 作为 已排序中的 最大值 
>
>  <font size= 5, color  = geen> 选择 的同时, 定好次序</font>
>
>  * 不稳定 排序
>  * 时间复杂度 为  O(N ^2)
>  * 交换元素的次数少 





> YY:隐喻 🌐  灌腊肠 ,  左手肠,右手肉, 先细后粗肉 填成 肠 

```C++
template<typename T>
void selectionSort(T arr[], int n){
	
	for(int i = 0; i < n; i++){
		//TODO		
		int minIndex = i;
		for(int j = i + 1; j < n; j++){
			if(arr[j] < arr[minIndex]){
				minIndex = j;
			}
		}
		
		std::swap(arr[i],arr[minIndex]);
	}
}
```

--

### 插入排序 ❓

---

> `已排序`  ,  `未排序`  
>
> 未排序中  依次 插入到  已排序中 
>
> <font  size= 5, color = geen>  选择不排序, 插入才排序</font>, 所以 叫 插入排序 
>
> * 稳定性 算法 
> * 平均每个元素 一定次数 为 O(N/2)

> YY 隐喻 :  收麦子 



```

```



# 算法思想

---



### 快慢指针 ✅

> **在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

---



![27.移除元素-双指针法](./%F0%9F%93%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E2%9A%A1-%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97.assets/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)





### 滑动窗口✅

---

![209.长度最小的子数组](./%F0%9F%93%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E2%9A%A1-%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97.assets/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

# 实现细节

---

### 随机数组 

> `rand() % (rangeR - rangeL + 1) + rangeL` 是用于生成一个在给定范围 `[rangeL, rangeR]` 内的随机整数。CopyCopyCopyCopy
>
> 通过 `rand()` 函数生成一个随机的整数。然后使用取模运算符 `%` 取得该随机整数对 `(rangeR - rangeL + 1)` 的余数。考虑到 `(rangeR - rangeL + 1)` 的结果是范围内整数的数量，加上 `rangeL` 后，可以将余数转换为在范围内的整数。CopyCopyCopyCopyCopyCopyCopyCopyCopy
>
> 例如，如果 `rangeL = 10`，`rangeR = 20`，那么 `(rangeR - rangeL + 1)` 的结果是 `11`，而 `rand() % 11` 将得到一个范围在 `0` 到 `10` 之间的随机整数。接着加上 `rangeL`，就将该随机整数转换为范围在 `10` 到 `20` 之间的随机整数。CopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopyCopy
>
> 换句话说，这段代码通过 `rand() % (rangeR - rangeL + 1) + rangeL`，可以生成一个位于指定范围的随机整数

```C++
	//生成有 n个元素的随机数组, 每个数组的随机范围是 (rangeL,rangeR)
	int *generateRandomArray(int n, int rangeL,int rangeR){
		
		assert(rangeL <= rangeR);  // 断言
		
		int* arr = new int[n];
		// 设置随机数生成器的种子 
		srand(time(NULL));
		for(int i = 0; i < n; i++)
		{
			arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;
		}
		
		return arr;
	}
```

